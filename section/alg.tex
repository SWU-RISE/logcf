
\section{Algorithm based on  continued fraction}
\label{sec:contalg}
In this section, we first recall Descartes' rule of signs, which gives a bound on the number of positive real roots. Then the Vincent theorem, which  ensures
the termination of algorithms based on  continued fraction, is presented. Finally, we review an algorithm of real root isolation based on  continued fraction.
%and the using the notation of \cite{akr05}.

As usual, $\deg(p)$ denotes the degree of univariate polynomial $p$. The derivative of polynomial $p$ with respect to the only variable is denoted by $p'$ and $\gcd(f,g)$ means the greatest common divisor of polynomials $f$ and $g$.

\begin{note}[Sign variation]
Let $S=\left\{ a_0,a_1,\ldots,a_n \right\}$ be a finite sequence of non-zero real numbers. Define $V(S)$, the {\em sign variation} of $S$, as follows.
\[V(S)=0\ \text{ if } |S|\le1,\]
\[  V(a_0,\ldots,a_{n-1},a_n)=  \left\{\begin{aligned}
 &  V(a_0,\ldots,a_{n-1})+1 \text{ if }a_{n-1}a_n<0;\\
&V(a_0,\ldots,a_{n-1}), \text{ otherwise}.\\
	\end{aligned}
	\right.
\]
If some elements of $S$ are zero, remove those zero-elements to get a new sequence and define $V(S)$ to be the sign variation of this new sequence.
\end{note}



\rev{There are many studies about  real roots for a given polynomial,  {\em Descartes' rule of signs} is one of 
beautiful results among them.   {\em Descartes' rule of signs}  provides a upper bound of the number of positive real roots.} 


\begin{theorem}[Descartes' rule of signs] \label{thm:des}
  Suppose $p=\sum_{i=0}^na_ix^i\in\RR[x]$ has $m$ positive real roots, counted with multiplicity. Set $V(p)=V(a_0,a_1,\ldots,a_n)$. Then $m\le V(p)$, and $V(p)-m$ is even.
\end{theorem}


\rev{ {\em Descartes' rule of signs} is a usefual tool to estimate the number of  real roots. And if $V(p)=1$, then employ this rule, there is 
  exact one  positive root.  But when $V(p)>1$, the rule can not directly isolate the real roots. {\em Vincent's theorem} in the following will
  overcome this restriction. {\em Vincent's theorem} says that if we give a small enough interval, then it can map this interval to all positive 
  domain and $V(p)\le 1$.}



\begin{theorem}[Vincent's theorem]\label{thm:vin}
  Let $p(x)$ be a real polynomial of degree $n$ which has only simple roots. It is possible to determine a positive quantity $\delta$ so that for every pair of positive real numbers $a$ and $b$ with $|b-a| < \delta$, the coefficients sequence of every transformed polynomial of the form
  $  p(x) = (1+x)^{n}p(\frac{a+bx}{1+x}) $
		  has exactly 0 or 1 sign variation. The second case is possible if and only if $p(x)$ has a single root within $(a,b)$.
\end{theorem}

\begin{algorithm}
\SetAlgoCaptionSeparator{.}
\caption{\algm \label{alg:main}}
\DontPrintSemicolon
\KwIn{ A non-zero polynomial $p(x)\in \ZZ[x] $. }
\KwOut{$I$  a set of real root isolating intervals of $p(x)$. }
$I=\emptyset$; \;
\If {$\deg(p)$  equals to $0$}  {return $I$;}
$P=\frac{p}{\gcd(p,p')}$; \tcc{ square free}
\If {$p(0)$   equals to  $0$ } { $I.add([0,0])$; \tcc{ add $[0,0]$ to set $I$}
\rev{$p=D(p$);} 
}
$I$.addAll(\algcf($p$)); \;
\tcc { add all the positive root intervals to set $I$ } \tcc{ \algcf\ is described as {\em Algorithm \ref{alg:cf}}}
\rev{$p=p(-x)$};\;
\rev{$I$.addAll(-\algcf($p$))}; 
\end{algorithm}


\begin{definition}  We define the following transformations for a univariate polynomial $p(x)=a_nx^n+a_{n-1}x^{n-1}+\cdots+a_1x+a_0,n>0$.
  \begin{eqnarray*}
  lc(p(x))&=&a_n,\\
  R(p(x))&=&x^n(p(\frac{1}{x})),\\
  H_\lambda(p(x))&=&p(\lambda x),\\
  T(p(x))&=&p(x+1), \\
  D(p(x))&=&a_nx^{n-1}+a_{n-1}x^{n-2}+\cdots+a_2x+a_1.
  \end{eqnarray*}
\end{definition}

$T(p)$  is also called	Taylor shift one \cite{ger04,joh05}. In our experiments when {\em Algorithm \ref{alg:up}} is used for computing upper bounds, $T(p)$  takes  more than
ninety percent of running time\footnote{the result of  GNU gprof.}.  We have considered methods in \cite{ger04} for computing $T(p)$, but   finally we chose the  classical
method (Horner's method) for its simplicity. In future work we will use Divide \& Conquer method which is the fastest in \cite{ger04}. We think \rev{further} substituting
will still improve the performance of our method.


\rev{{\em Vincent's theorem} provides  a possible method to isolate the real roots. But it needs to divide all $\RR$ to small many intervals and the width of these intervals is smaller than a given  finite value. Hence, it can not   directly use {\em Vincent's theorem} to isolate the real roots. For employing  {\em Vincent's theorem}, we need to discard  the interval which can make sure there is no the real root in it. {\em Algorithm \ref{alg:lb}} provide a lower  bound $lu$ of positive roots for given $p$, then interval  $(0,lb)$ contains no the real roots, so we can safely  discard
	$(0,lb)$ when isolate the real roots. }


\begin{algorithm}
\SetAlgoCaptionSeparator{.}
\caption{\lb \label{alg:lb}}
\DontPrintSemicolon
\KwIn{ $p\in\ZZ[x],lc(p)\neq 0 $. }
\KwOut{$root\_lb$, a lower bound of positive roots of $p$. }
$p=R(p)$;\;
\lIf{$lc(p)<0$}{	$p=-p$;} 
$root\_lb=$\up($p$); \tcc{\up\ is described as {\em Algorithm \ref{alg:up}}}
\end{algorithm}


\begin{definition}
$  intvl(a,b,c,d)=  \left\{\begin{aligned}
&  (\min\left\{ \frac{a}{c},\frac{b}{d} \right\},\max\left\{ \frac{a}{c},\frac{b}{d} \right\} ) &\text{ if } cd\neq0;\\
& (0,\infty), &\text{ otherwise}.\\
	\end{aligned}
	\right.
$
\end{definition}


Using the above notations and definitions, an algorithm for isolating all the real roots of a nonzero univariate polynomial is described as {\em Algorithm \ref{alg:main}}.
{\em Algorithm \ref{alg:cf}}, which \rev{is a slight}   modification of the algorithm in \cite{akr08}, is presented here to make our subsequent description clearer.




Continued fraction based procedures will continue subdividing the considered interval into two subintervals and make a one to one map from $(a,b)$ to $(0,+\infty)$ by $  p(x) = (1+x)^{n}p(\frac{a+bx}{1+x})$ until $V(p)$ equals $1$ or $0$. \rev{Informally, {\em Algorithm \ref{alg:main}} is employing  above map to magnify the considered interval  to $(0,+\infty)$.  Through {\em Descartes' rule of signs}, there is no positive real root if  $V(p)=0$. In this case we throw away the interval from the considered intervals set.   When $V(p)=1$, then the interval contain exact one real root by {\em Descartes' rule of signs}. In this case we throw away the interval from the considered intervals set. When $V(p)>1$, in other words, it can not make sure how many real roots are contained in this interval, then we divide the considered interval into two subintervals. In this case we throw away the interval from the considered intervals set and add two subintervals to the considered intervals set.  Repeating this procedure  we can 
	divide 	the  interval into  subintervals until  there is no size of  the corresponding original interval greater or equal to $\delta$ for interval in onsidered intervals set.   Then there is at most one real root in every interval in considered interval set and the procedure will terminal. This is also
	the reason of why}
{\em Theorem \ref{thm:vin}}  can guarantee the termination of {\em Algorithm \ref{alg:main}}.



\begin{algorithm}
	\SetAlgoCaptionSeparator{.}
	\caption{\algcf \label{alg:cf}}
	\DontPrintSemicolon
	\KwIn{ A squarefree polynomial $p \in \ZZ[x] \setminus \{0\}$. }
	\KwOut{ $roots$, a list of isolating intervals of positive roots of $p$. }
	
	$roots=\emptyset$;
	$s=V(p)$;\;

	$intstack=\emptyset$;
	$intstack$.add($\{1,0,0,1,p,s\}$);\;
	\While{$intstack\neq \emptyset$} {
		$\{a,b,c,d,p,s\}=intstack.$pop();\tcc{pop  the first element}
		$\gamma=\lb(p)$;\;
		\lIf{$\gamma \ge 1$ }{
			$\{ a,c,p \}=\{ \gamma  a,\gamma c ,H_\gamma(p) \}$;
			$\{ b,d,p \}=\{   a+b,c+d ,T(p) \}$;\;
			\lIf { $p(0)= = 0$}{
				$roots$.add$([\frac{b}{d},\frac{b}{d}])$ ;
				$p=\frac{p}{x}$;}
			$s=V(p)$;
			\lIf {$s= = 0$}{
				continue;
			}
			\lElseIf{$s= = 1$}{		
				$roots$.add($intvl(a,b,c,d)$);
				continue;
			}
		}
		$ \left\{ p_1,a_1,b_1,c_1,d_1,r \right\}=\left\{ T(p),a,a+b,c,c+d,0 \right\}$
		
		\lIf{$p_1(0)= =0$}{
			$roots$.add($[\frac{b_1}{d_1},\frac{b_1}{d_1}]$);
			$p_1=\frac{p_1}{x};r=1$;
		}
		$s_1=V(p_1)$;
		$\left\{ s_2,a_2,b_2,c_2,d_2 \right\}=\left\{ s-s_1-r,b,a+b,d,c+d \right\}$;
		%$ s_2 = s- s_1 - r; a_2 = b; b_2 = a + b; c_2 = d; d_2 = c + d$;\;
		\lIf {$s_2>1$ }{
			$ p_2= (x+1)^{\deg(p)}T(p)$;\;
			\lIf {$p_2(0)= = 0$}{
				$p_2=\frac{p_2}{x}$;
				$s_2=V(p_2)$;
			}
		}
		\lIf{$s_1= = 1$ }{
			$roots$.add($intvl(a_1,b_1,c_1,d_1)$);\;
		}
		\lElseIf{$s_1>1$ }{
			$intstack$.add($\{a_1,b_1,c_1,d_1,p_1,s_1\}$);\;
		}
		
		\lIf{$s_2= = 1$}{
			$roots$.add($intvl(a_2,b_2,c_2,d_2)$);\;
		}
		\lElseIf{$s_2>1$ }{
			$intstack$.add($\{a_2,b_2,c_2,d_2,p_2,s_2\}$);\;
		}
	}
\end{algorithm}

